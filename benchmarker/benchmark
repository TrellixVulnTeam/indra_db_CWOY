#!/usr/bin/env python

import os
import json
import boto3
import logging
from datetime import datetime
from argparse import ArgumentParser
from inspect import getmembers, isfunction
from importlib.util import spec_from_file_location, module_from_spec

logger = logging.getLogger('benchmarker')


def benchmark(loc, base_name=None):
    # By default, just run in this directory
    if loc is None:
        loc = os.path.abspath('.')

    # Extract a function name, if it was included.
    if loc.count(':') == 0:
        func_name = None
    elif loc.count(':') == 1:
        loc, func_name = loc.split(':')
    else:
        raise ValueError(f"Invalid loc: {loc}")
    mod_name = os.path.basename(loc).replace('.py', '')
    if base_name:
        mod_name = base_name + '.' + mod_name

    # Check if the location exists, and whether it is a directory or file.
    # Handle the file case by recursively calling this function for each file.
    results = {}
    if not os.path.exists(loc):
        raise ValueError(f"No such file or directory: {loc}")
    elif os.path.isdir(loc):
        if func_name is not None:
            raise ValueError("To specify function, location must be a file.")
        for file in os.listdir(loc):
            new_path = os.path.join(loc, file)
            if ('test' in file and os.path.isfile(new_path)
                    and new_path.endswith('.py')):
                results.update(benchmark(new_path, base_name=mod_name))
        return results

    # Handle the case a file is specified.
    if not loc.endswith('.py'):
        raise ValueError(f"Location {loc} is not a python file.")
    print("="*len(loc))
    print(loc)
    print('-'*len(loc))
    spec = spec_from_file_location(mod_name, loc)
    test_module = module_from_spec(spec)
    try:
        spec.loader.exec_module(test_module)
    except Exception as err:
        logger.error(f"Failed to load {loc}, skipping...")
        logger.exception(err)
        return results

    # Run tests
    tests = (f for f, _ in getmembers(test_module, isfunction) if 'test' in f)
    for test_name in tests:
        test_results = dict.fromkeys(['passed', 'error_type', 'error_str',
                                      'duration'])
        print(test_name)
        print('-'*len(test_name))
        print("LOGS:")
        test = getattr(test_module, test_name)
        start = datetime.now()
        try:
            test()
            print('-'*len(test_name))
            print("PASSED!")
            test_results['passed'] = True
        except Exception as e:
            print('-'*len(test_name))
            print("FAILED!", type(e), e)
            test_results['passed'] = False
            test_results['error_type'] = str(type(e))
            test_results['error_str'] = str(e)
        finally:
            end = datetime.now()
            test_results['duration'] = (end - start).total_seconds()
            print()
            results[f'{mod_name}.{test_name}'] = test_results

    return results


def main():
    start_time = datetime.utcnow()
    parser = ArgumentParser(
        description=('Run tests and benchmark time to run and '
                     'errors.'))
    parser.add_argument(dest='location')
    parser.add_argument(dest='stack_name')
    args = parser.parse_args()
    results = benchmark(args.location)
    for test, stats in results.items():
        print(test, stats)
    s3 = boto3.client('s3')
    s3.put_object(Bucket='bigmech',
                  Key=f'indra-db/benchmarks/{args.stack_name}/{start_time}.json',
                  Body=json.dumps(results))


if __name__ == '__main__':
    main()
